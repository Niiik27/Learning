numberList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 22, 11, 10, 6, 5, 22]


def delNumber(massiv, recurs=0):  # Добавил параметр, что бы проследить этапы рекурсии.
    """
    Это рекурсивная функция
    Она делает множественное удаление элементов из массива
    """

    print("вошел>>", massiv, "кол-во", len(massiv), "рекурсия", recurs)

    # Запускаем цикл на весь массив
    for i in range(0, len(massiv)):
        if i == len(massiv):  # Здесь завершится рекурсия
            print("Точка возврата", massiv, "рекурсия", recurs)
            return massiv
        elif massiv[i] % 2 == 0:
            recurs += 1
            """
            По скольку функция будет вызываться много раз, и будет обрабатывать исходный массив,
            то будет интересно наблюдать результат обработки на каждой итерации
            Так же смотрим и длину массива, что бы легче было заметить значимые изменения или не изменения
            Здесь удаляем четные числа в массиве. Может быть любое условие, на основании которого можно удалить
            несколько значений.
            """
            massiv.pop(i)
            print("<<ВЫШЕЛ", massiv, "кол-во", len(massiv), "рекурсия", recurs - 1)

            """
            Здесь есть подвох в виде цикла и условия проверки длины массива.
            Как только находится элемент удовлетворяющий условию удаления - он удаляется, и повторно вызывается
            метод удаления. При этом цикл заряжен на изначальную длину массива. То есть когда отработает метод
            произойдет следующая итерация, даже если длина обрабатываемого массива меньше чем i
            Пока что сохраняется проблема изменения размера массива во время итерации.
            То же самое произойдет внутри повторного вызова, и так до тех пор пока не произойдет условия для return
            тогда рекурсии больше не будет. Это произойдет когда в массиве не останется четных чисел.
            Последний вызов метода завершится и вернет получившийся массив.
            Предпоследний вызов метода - завершится, так как он ждал отработки внутреннего вызова данного метода
            При этом произойдет заход на новую итерацию. Четных чисел этот цикл больше не найдет - их там больше нет,
            а значит произойдет return, когда i станет равной длине обработанного массива.
            Тоже самое произойдет в верхнем вызове метода, и так до самого верха.
            Стоит отметить, что поиск идет слева на право, и всякий раз удаляется первый найденый соответствующий
            элемент, по этому состояние i>len(massiv) не наступит, а будет перехвачено проверкой i==len(massiv)
            Значение recurs так же сохранится таким каким оно было до вызова метода
            """
           
            delNumber(massiv, recurs)


print("numberList", numberList)
print("delNumber", delNumber(numberList))
print("numberList", numberList)

"""
Упростил метод для отслеживания рекурсии. видно разное поведение для
simple_recursion(recurs) и recurs = simple_recursion(recurs)
"""
print()
print("*********************** Упрощеная рекурсия без писваивания нового значения  ***********************")

def simple_recursion(recurs=5):
    for i in range(recurs + 1):
        if recurs == 0:
            print("Точка возврата", recurs)
            return recurs
        elif recurs > 0:
            print("вошел>>", recurs)
            recurs -= 1
            """
            В начале все понятно - будет вызов метода пока не дойдем до условия выхода. По этому проследим за
            происходящим с момента выхода
            Происходит возврат в верхний вызов. В нем цикл на 2 итерации, одна уже исполнена. Происходит вторая
            итерация. Перед вызовом recurs стал равен 0. По этому на этой итерации попадаем в условие выхода
            В верхнем вызове recurs был равен 1. По этому попадаем в условие рекурсии и recurs уменьшается на 1.
            Происходит повторение ситуации. После этого возвраты отправят еще на один вызов выше, но там recurs был
            равен 2, и оставалось еще 2 итерации, опять две рекурсии, и два уменьшения recurs... Последить и описать
            весь процесс - сложно. Суть в том что в процессе перед каждой рекурсией происходит приближение к выходу - 
            уменьшение recurs и так до тех пор пока не будет достигнут 0. Происходит множественный запуск функции, в
            зависимости от того на сколько далеко он находится от 0. Все решает уменьшение числа в цикле, а рекурсия
            просто идет следом, толком не выполняя полезного действия
            """
            simple_recursion(recurs)
            


num_recurs = 5
# simple_recursion(num_recurs)
print("simple_recursion", simple_recursion(num_recurs))
print()
print("*********************** Упрощеная рекурсия с пирсваиванием нового значения  ***********************")

def simple_recursion(recurs=5):
    for i in range(recurs + 1):
        if recurs == 0:
            print("Точка возврата", recurs)
            return recurs
        elif recurs > 0:
            print("вошел>>", recurs)
            recurs -= 1
            """        
            На много проще, когда recurs переопределяется данным методом.
            На любом уровне следующая итерация будет соответствовать условию выхода. Все верхние уровни последовательно
            завершатся возвратом 0
            """
            recurs = simple_recursion(recurs)


num_recurs = 5
# simple_recursion(num_recurs)
print("simple_recursion", simple_recursion(num_recurs))
print()





print("*********************** Задание 2 ***********************")
print("*********************** Удаление клиентов рекурсией ***********************")
clientList = {
    "Меньшиков": "оплачено",
    "Выборнов": "не оплачено",
    "Курочкин": "оплачено",
    "Мухитов": "не оплачено",
    "Попов": "оплачено",
    "Чепаксин": "не оплачено",
    "Карпов": "оплачено",
    "Соколов": "не оплачено",
    "Захаров": "оплачено",
    "Казаков": "не оплачено",
    "Хисамов": "оплачено",
}


def del_persons_recursively(clientList: dict, del_status="не оплачено"):
    for client in clientList:
        if clientList[client] == del_status:
            clientList.pop(client)
            return del_persons_recursively(clientList)
    return clientList

def del_persons_recursively11(clientList: dict, del_status="не оплачено"):
    """
    так тоже будет работать
    """
    for client in clientList:
        if clientList[client] == del_status:
            clientList.pop(client)
            del_persons_recursively(clientList)
            break


clientNames = "Список клиентов до удаления:\n"
for client in clientList:
    clientNames += f"{client} - {clientList[client]}\n"
print(clientNames)
del_persons_recursively(clientList)
clientNames = "Список клиентов после удаления:\n"
for client in clientList:
    clientNames += f"{client} - {clientList[client]}\n"
print(clientNames)


print("*********************** Удаление клиентов в цикле ***********************")
clientList = {
    "Меньшиков": "оплачено",
    "Выборнов": "не оплачено",
    "Курочкин": "оплачено",
    "Мухитов": "не оплачено",
    "Попов": "оплачено",
    "Чепаксин": "не оплачено",
    "Карпов": "оплачено",
    "Соколов": "не оплачено",
    "Захаров": "оплачено",
    "Казаков": "не оплачено",
    "Хисамов": "оплачено",
}
def del_persons(clientList):
    del_status = "не оплачено"
    clientNames = "Список клиентов до удаления:\n"
    for client in clientList:
        clientNames += f"{client} - {clientList[client]}\n"
    print(clientNames)
    
    
    while True:
        del_client = False
        for client in clientList:
            if clientList[client] == del_status:
                clientList.pop(client)
                del_client = True
                break
        if del_client == False: break


    clientNames = "Список клиентов после удаления:\n"
    for client in clientList:
        clientNames += f"{client} - {clientList[client]}\n"
    print(clientNames)


del_persons(clientList)

"""
Была еще мысль - сначала создать новый массив с удаляемыми объектами, на его основе запустить цикл
и в основном массиве удалять эти самые объекты
"""
clientList = {
    "Меньшиков": "оплачено",
    "Выборнов": "не оплачено",
    "Курочкин": "оплачено",
    "Мухитов": "не оплачено",
    "Попов": "оплачено",
    "Чепаксин": "не оплачено",
    "Карпов": "оплачено",
    "Соколов": "не оплачено",
    "Захаров": "оплачено",
    "Казаков": "не оплачено",
    "Хисамов": "оплачено",
}
print("*********************** Удаление клиентов при помощи массива ***********************")
def del_with_array():
    """
    Сначала не хотел его писать, но потом вспомнил про генератор массива. И еще задумался об общем
    количестве итераций. В общем код предполагался небольшим но интересным
    В случае рекурсии мы удаляем элемент, заново входим метод, и заново начинаем поиск очередного элемента
    Со списком можно было бы передавать индекс с которого начинать поиск, и таким образом уменьшить общее
    количество итераций.
    Со словарем по проще, не считая того что скрывается в методе pop. подозреваю поиск занимает время
    в зависимости от размера словаря. На каждой рекурсии метод получает максимальный размер словаря
    А когда поиск не дает результатов происходит выход из рекурсии - выход из всех предыдущих вызовов
    тоже доп нагрузка
    В случае удаления в цикле - нужно удалять до тех пор пока не произойдет поиска по всему
    оставшемуся массиву без удаления - получается много лишних итераций

    В случае  создания дополнительного массива - сначала произойдет одна итерация по исходному массиву
    Затем итерация по меньшему массиву с выбранными элементами. И будет только один return
    Все выглядит на много быстрее, не считая усилий потраченных на копирование элементов
    Но в любом случае этот код максимально простой и понятный
    Так что написал и его
    """
    del_keys = [x for x in clientList if clientList[x] == "не оплачено"]
    for key in del_keys: clientList.pop(key)




clientNames = "Список клиентов до удаления:\n"
for client in clientList:
    clientNames += f"{client} - {clientList[client]}\n"
print(clientNames)
del_with_array()
clientNames = "Список клиентов после удаления:\n"
for client in clientList:
    clientNames += f"{client} - {clientList[client]}\n"
print(clientNames)



