numberList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 22, 11, 10, 6, 5, 22]


def delNumber(massiv, recurs=0):  # Добавил параметр, что бы проследить этапы рекурсии.
    """
    Это рекурсивная функция
    Она делает множественное удаление элементов из массива
    """

    print("вошел>>", massiv, "кол-во", len(massiv), "рекурсия", recurs)

    # Запускаем цикл на весь массив
    for i in range(0, len(massiv)):
        if i == len(massiv):  # Здесь завершится рекурсия
            print("Точка возврата", massiv, "рекурсия", recurs)
            return massiv
        elif massiv[i] % 2 == 0:
            recurs += 1
            """
            По скольку функция будет вызываться много раз, и будет обрабатывать исходный массив,
            то будет интересно наблюдать результат обработки на каждой итерации
            Так же смотрим и длину массива, что бы легче было заметить значимые изменения или не изменения
            Здесь удаляем четные числа в массиве. Может быть любое условие, на основании которого можно удалить
            несколько значений.
            """
            massiv.pop(i)
            print("<<ВЫШЕЛ", massiv, "кол-во", len(massiv), "рекурсия", recurs - 1)

            """
            Здесь есть подвох в виде цикла и условия проверки длины массива.
            Как только находится элемент удовлетворяющий условию удаления - он удаляется, и повторно вызывается
            метод удаления. При этом цикл заряжен на изначальную длину массива. То есть когда отработает метод
            произойдет следующая итерация, даже если длина обрабатываемого массива меньше чем i
            Пока что сохраняется проблема изменения размера массива во время итерации.
            То же самое произойдет внутри повторного вызова, и так до тех пор пока не произойдет условия для return
            тогда рекурсии больше не будет. Это произойдет когда в массиве не останется четных чисел.
            Последний вызов метода завершится и вернет получившийся массив.
            Предпоследний вызов метода - завершится, так как он ждал отработки внутреннего вызова данного метода
            При этом произойдет заход на новую итерацию. Четных чисел этот цикл больше не найдет - их там больше нет,
            а значит произойдет return, когда i станет равной длине обработанного массива.
            Тоже самое произойдет в верхнем вызове метода, и так до самого верха.
            Стоит отметить, что ипоиск идет слева на право, и всякий раз удаляется первый найденый соответствующий
            элемент, по этому состояние i>len(massiv) не наступит, а будет перехвачено проверкой i==len(massiv)
            Значение recurs так же сохранится таким каким оно было до вызова метода
            """
            """
            Есть еще небольшой подвох который мы не изучали, и доберемся до него наверное на стадии ООП
            метод delNumber возвращает новое значение, но оно не присваивается переменной massiv, при этом все работает
            это происходит потому что объекты передаются методам по ссылке, и все что в них происходит - сохраняется
            в них. Необязательно делать return что бы вернуть измененный объект. Он и так уже изменен
            А для простых и неизменяемых типов потребуется return, так как потребуется присвоить новое значение
            Но на данном этапе рекурсия должна выглядеть так massiv = delNumber(massiv, recurs)
            """

            delNumber(massiv, recurs)


print("numberList", numberList)
print("delNumber", delNumber(numberList))
print("numberList", numberList)

"""
Упростил метод для отслеживания рекурсии. видно разное поведение для
simple_recursion(recurs) и recurs = simple_recursion(recurs)
"""


def simple_recursion(recurs=5):
    for i in range(recurs + 1):
        if recurs == 0:
            print("Точка возврата", recurs)
            return recurs
        elif recurs > 0:
            print("вошел>>", recurs)
            recurs -= 1
            """
            В начале все понятно - будет вызов метода пока не дойдем до условия выхода. По этому проследим за
            происходящим с момента выхода
            Происходит возврат в верхний вызов. В нем цикл на 2 итерации, одна уже исполнена. Происходит вторая
            итерация. Перед вызовом recurs стал равен 0. По этому на этой итерации попадаем в условие выхода
            В верхнем вызове recurs был равен 1. По этому попадаем в условие рекурсии и recurs уменьшается на 1.
            Происходит повторение ситуации. После этого возвраты отправят еще на один вызов выше, но там recurs был
            равен 2, и оставалось еще 2 итерации, опять две рекурсии, и два уменьшения recurs... Последить и описать
            весь процесс - сложно. Суть в том что в процессе перед каждой рекурсией происходит приближение к выходу - 
            уменьшение recurs и так до тех пор пока не будет достигнут 0. Происходит множественный запуск функции, в
            зависимости от того на сколько далеко он находится от 0. Все решает уменьшение числа в цикле, а рекурсия
            просто идет следом, толком не выполняя полезного действия
            
            На много проще, когда recurs переопределяется данным методом.
            На любом уровне следующая итерация будет соответствовать условию выхода. Все верхние уровни последовательно
            завершатся возвратом 0
            """
            simple_recursion(recurs)
            # recurs = simple_recursion(recurs)


num_recurs = 5
# simple_recursion(num_recurs)
print("simple_recursion", simple_recursion(num_recurs))
print()
print("*********************** Удаление клиентов рекурсией ***********************")
clientList = {
    "Меньшиков": "оплачено",
    "Выборнов": "не оплачено",
    "Курочкин": "оплачено",
    "Мухитов": "не оплачено",
    "Попов": "оплачено",
    "Чепаксин": "не оплачено",
    "Карпов": "оплачено",
    "Соколов": "не оплачено",
    "Захаров": "оплачено",
    "Казаков": "не оплачено",
    "Хисамов": "оплачено",
}


def del_persons_recursively(clientList: dict, del_status="не оплачено"):
    for client in clientList:
        if clientList[client] == del_status:
            clientList.pop(client)
            del_persons_recursively(clientList)
            break
    # return clientList


clientNames = "Список клиентов до удаления:\n"
for client in clientList:
    clientNames += f"{client} - {clientList[client]}\n"
print(clientNames)
del_persons_recursively(clientList)
clientNames = "Список клиентов после удаления:\n"
for client in clientList:
    clientNames += f"{client} - {clientList[client]}\n"
print(clientNames)


print("*********************** Удаление клиентов в цикле ***********************")
clientList = {
    "Меньшиков": "оплачено",
    "Выборнов": "не оплачено",
    "Курочкин": "оплачено",
    "Мухитов": "не оплачено",
    "Попов": "оплачено",
    "Чепаксин": "не оплачено",
    "Карпов": "оплачено",
    "Соколов": "не оплачено",
    "Захаров": "оплачено",
    "Казаков": "не оплачено",
    "Хисамов": "оплачено",
}
def del_persons(clientList):
    del_status = "не оплачено"
    clientNames = "Список клиентов до удаления:\n"
    for client in clientList:
        clientNames += f"{client} - {clientList[client]}\n"
    print(clientNames)
    while True:
        del_client = False
        for client in clientList:
            if clientList[client] == del_status:
                clientList.pop(client)
                del_client = True
                break
        if del_client == False: break
    clientNames = "Список клиентов после удаления:\n"
    for client in clientList:
        clientNames += f"{client} - {clientList[client]}\n"
    print(clientNames)


del_persons(clientList)





